import { FileGenerator, FileGeneratorType, Question, QuestionType } from '@kaapi/cli/definitions'
import { camelCase, kebabCase } from '@kaapi/cli/utils'

enum TYPE_ENUM {
    dpopReplayDetector = 'dpop-replay-detector',
    jwksKeyStore = 'jwks-key-store',
    jwksRotationTimestampStore = 'jwks-rotation-timestamp-store'
}

const TYPE_OPTIONS: {
    value: string;
    label: string;
    hint: string;
}[] = [
        {
            value: TYPE_ENUM.dpopReplayDetector,
            label: 'DPoP Replay Detector',
            hint: ''
        },
        {
            value: TYPE_ENUM.jwksKeyStore,
            label: 'Jwks Key Store',
            hint: ''
        },
        {
            value: TYPE_ENUM.jwksRotationTimestampStore,
            label: 'Jwks Rotation Timestamp Store',
            hint: ''
        },
    ];

export class OAuth2UtilGenerator implements FileGenerator {

    get type(): FileGeneratorType {
        return 'others'
    }

    get name(): 'oauth2-util' {
        return 'oauth2-util'
    }

    get description(): string {
        return 'Creates util.'
    }

    get notes(): string[] {
        return [
            'Allowed values for --type:',
            ...TYPE_OPTIONS.map(o => `  - ${o.value}`)
        ]
    }

    get options(): Record<string, string> {
        return {
            name: 'The name',
            type: 'The type'
        }
    }

    #values = {
        name: '',
        type: ''
    }

    init(options: Record<string, unknown>): void {
        if (typeof options['name'] == 'string') {
            this.#values.name = camelCase(options['name'])
        }
        if (typeof options['type'] == 'string') {
            if (!TYPE_OPTIONS.map(v => v.value).includes(options['type'])) {
                throw new Error(`Invalid value for '--type'. Allowed values are: ${TYPE_OPTIONS.map(v => v.value).join(', ')}.`)
            }
            this.#values.type = options['type']
        }
    }

    isValid(): boolean {
        return !!(this.#values.name && this.#values.type)
    }

    getFileContent(): string {
        if (this.#values.type === TYPE_ENUM.dpopReplayDetector)
            return this.#getDpopReplayDetectorContent()
        else if (this.#values.type === TYPE_ENUM.jwksKeyStore)
            return this.#getJwksKeyStoreContent()
        else if (this.#values.type === TYPE_ENUM.jwksRotationTimestampStore)
            return this.#getJwksRotationTimestampStoreContent()
        else
            return ''
    }

    getQuestions(): Question[] {
        const r: Question[] = []

        if (!(this.#values.type && TYPE_OPTIONS.map(v => v.value).includes(this.#values.type))) {
            r.push({
                type: QuestionType.select,
                options: {
                    message: 'The type?',
                    options: TYPE_OPTIONS
                },
                setValue: (value) => {
                    this.#values.type = `${value}`
                }
            })
        }

        if (!this.#values.name) {
            const camelCasedType = camelCase(this.#values.type || 'custom-util')
            r.push({
                type: QuestionType.text,
                options: {
                    message: 'The name?',
                    defaultValue: camelCasedType,
                    placeholder: camelCasedType
                },
                setValue: (pluginName) => {
                    this.#values.name = camelCase(pluginName)
                }
            })
        }

        return r
    }

    getFilename(): string {
        return kebabCase(`${this.#values.name}`) + '.ts'
    }

    #getDpopReplayDetectorContent(): string {
        return `// generated by @kaapi/oauth2-auth-design

import { ReplayDetector } from '@kaapi/oauth2-auth-design'

/**
 * A custom implementation of a DPoP (Demonstration of Proof-of-Possession) replay detector.
 * Provides methods to track and prevent replay attacks by storing and checking unique values
 * with a defined time-to-live.
 */
export const ${this.#values.name}: ReplayDetector = {
    /**
     * Checks whether a given value has already been seen (i.e., replayed).
     *
     * @param {string} value - The unique identifier to check for replay.
     * @returns {Promise<boolean>} A promise that resolves to \`true\` if the value exists
     * (indicating a replay), or \`false\` if it has not been seen before.
     */
    has(value: string): Promise<boolean> {
        throw new Error('Method not implemented.');
    },

    /**
     * Deletes a previously stored value from the replay detector.
     *
     * @param {string} value - The unique identifier to remove from storage.
     * @returns {Promise<void>} A promise that resolves when the value has been deleted.
     */
    delete(value: string): Promise<void> {
        throw new Error('Method not implemented.');
    },

    /**
     * Adds a new value to the replay detector with a specified time-to-live.
     *
     * @param {string} value - The unique identifier to store for replay detection.
     * @param {number} ttlSeconds - The time-to-live in seconds, after which the value expires.
     * @returns {Promise<void>} A promise that resolves when the value has been stored.
     */
    add(value: string, ttlSeconds: number): Promise<void> {
        throw new Error('Method not implemented.');
    }
};
`
    }

    #getJwksKeyStoreContent(): string {
        return `// generated by @kaapi/oauth2-auth-design

import { JwksKeyStore } from '@kaapi/oauth2-auth-design';

/**
 * A custom implementation of a JSON Web Key Store (JWKS).
 * Provides methods to store and retrieve key pairs used for signing and verifying JWTs.
 */
export const ${this.#values.name}: JwksKeyStore = {
    /**
     * Stores a key pair (private and public keys) in the JWKS with a given key ID and time-to-live.
     *
     * @param {string} kid - The Key ID (KID) used to uniquely identify the key pair.
     * @param {object} privateKey - The private key object used for signing tokens.
     * @param {object} publicKey - The public key object used for verifying tokens.
     * @param {number} ttl - The time-to-live (in seconds) for how long the key pair should remain valid.
     * @returns {void | Promise<void>} Returns nothing or a promise that resolves when the key pair is stored.
     */
    storeKeyPair(kid: string, privateKey: object, publicKey: object, ttl: number): void | Promise<void> {
        throw new Error('Function not implemented.');
    },

    /**
     * Retrieves the private key currently stored in the JWKS.
     *
     * @returns {Promise<object | undefined>} A promise that resolves to the private key object,
     * or \`undefined\` if no private key is available.
     */
    getPrivateKey(): Promise<object | undefined> {
        throw new Error('Function not implemented.');
    },

    /**
     * Retrieves all public keys currently stored in the JWKS.
     *
     * @returns {Promise<object[]>} A promise that resolves to an array of public key objects.
     */
    getPublicKeys(): Promise<object[]> {
        throw new Error('Function not implemented.');
    }
};
`
    }

    #getJwksRotationTimestampStoreContent(): string {
        return `// generated by @kaapi/oauth2-auth-design

import { JwksRotationTimestampStore } from '@kaapi/oauth2-auth-design';

/**
 * A custom implementation of a JWKS rotation timestamp store.
 * Provides methods to persist and retrieve the last rotation timestamp
 * for JSON Web Key Sets (JWKS).
 */
export const ${this.#values.name}: JwksRotationTimestampStore = {
    /**
     * Retrieves the timestamp of the last JWKS rotation.
     *
     * @returns {Promise<number>} A promise that resolves to the last rotation timestamp
     * in milliseconds since the Unix epoch.
     */
    getLastRotationTimestamp: function (): Promise<number> {
        throw new Error('Function not implemented.');
    },

    /**
     * Sets the timestamp of the last JWKS rotation.
     *
     * @param {number} rotationTimestamp - The rotation timestamp to store,
     * expressed in milliseconds since the Unix epoch.
     * @returns {Promise<void>} A promise that resolves when the timestamp has been stored.
     */
    setLastRotationTimestamp: function (rotationTimestamp: number): Promise<void> {
        throw new Error('Function not implemented.');
    }
};
`
    }
}