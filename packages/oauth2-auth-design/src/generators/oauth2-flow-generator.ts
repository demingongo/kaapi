import { FileGenerator, FileGeneratorType, Question, QuestionType } from '@kaapi/cli/definitions'
import { camelCase, kebabCase } from '@kaapi/cli/utils'

enum FLOW_ENUM {
    oidcAuthCode = 'oidc-auth-code',
    oidcClientCredentials = 'oidc-client-credentials',
    oidcDeviceFlow = 'oidc-device-auth'
}

const FLOW_OPTIONS: {
    value: string;
    label: string;
    hint: string;
}[] = [
        {
            value: FLOW_ENUM.oidcAuthCode,
            label: 'OIDC Authorization Code',
            hint: ''
        },
        {
            value: FLOW_ENUM.oidcClientCredentials,
            label: 'OIDC Client Credentials',
            hint: ''
        },
        {
            value: FLOW_ENUM.oidcDeviceFlow,
            label: 'OIDC Device Authorization',
            hint: ''
        }
    ];

export class OAuth2FlowGenerator implements FileGenerator {

    get type(): FileGeneratorType {
        return 'auth-design'
    }

    get name(): 'oauth2-flow' {
        return 'oauth2-flow'
    }

    get description(): string {
        return 'Creates an auth design based on OAuth2 specifications.'
    }

    get notes(): string[] {
        return [
            'Allowed values for --flow:',
            ...FLOW_OPTIONS.map(o => `  - ${o.value}`)
        ]
    }

    get options(): Record<string, string> {
        return {
            name: 'The name of the strategy',
            flow: 'The grant type flow'
        }
    }

    #values = {
        name: '',
        flow: ''
    }

    init(options: Record<string, unknown>): void {
        if (typeof options['name'] == 'string') {
            this.#values.name = camelCase(options['name'])
        }
        if (typeof options['flow'] == 'string') {
            if (!FLOW_OPTIONS.map(v => v.value).includes(options['flow'])) {
                throw new Error(`Invalid value for '--flow'. Allowed values are: ${FLOW_OPTIONS.map(v => v.value).join(', ')}.`)
            }
            this.#values.flow = options['flow']
        }
    }

    isValid(): boolean {
        return !!this.#values.name
    }

    getFileContent(): string {
        if (this.#values.flow === FLOW_ENUM.oidcAuthCode)
            return this.#getOidcAuthCodeContent()
        else if (this.#values.flow === FLOW_ENUM.oidcClientCredentials)
            return this.#getOidcClientCredentialsContent()
        else if (this.#values.flow === FLOW_ENUM.oidcDeviceFlow)
            return this.#getOidcDeviceFlowContent()
        else
            return ''
    }

    getQuestions(): Question[] {
        const r: Question[] = []

        if (!this.#values.name) {
            r.push({
                type: QuestionType.text,
                options: {
                    message: 'The name of the strategy?',
                    defaultValue: 'oauth2-strategy',
                    placeholder: 'oauth2-strategy'
                },
                setValue: (value) => {
                    this.#values.name = camelCase(value)
                }
            })
        }

        if (!(this.#values.flow && FLOW_OPTIONS.map(v => v.value).includes(this.#values.flow))) {
            r.push({
                type: QuestionType.select,
                options: {
                    message: 'The authorization flow?',
                    options: FLOW_OPTIONS,
                    initialValue: 'oidc-auth-code'
                },
                setValue: (value) => {
                    this.#values.flow = `${value}`
                }
            })
        }

        return r
    }

    getFilename(): string {
        return kebabCase(`${this.#values.name}`) + '.ts'
    }

    #getOidcAuthCodeContent(): string {
        return `// generated by @kaapi/oauth2-auth-design

import {
    BearerToken,
    OIDCAuthorizationCodeBuilder,
    createInMemoryKeyStore,
    createMatchAuthCodeResult,
    OAuth2TokenResponse,
    ClientSecretBasic,
    ClientSecretPost,
    NoneAuthMethod,
    OAuth2ErrorCode,
} from '@kaapi/oauth2-auth-design';

const VALID_CLIENTS = [
    {
        client_id: 'service-api-client',
        client_secret: 's3cr3tK3y123!',
        allowed_scopes: ['openid', 'profile', 'email', 'read', 'write'],
    },
];

const REGISTERED_USERS = [{ id: 'user-1234', username: 'user', password: 'password', email: 'user@email.com' }];

const authCodesStore: Map<
    string,
    { clientId: string; scopes: string[]; userId: string; codeChallenge?: string | undefined }
> = new Map();

export const oidcAuthCodeBuilder = OIDCAuthorizationCodeBuilder.create()
    // the name of the strategy
    .strategyName('${kebabCase(this.#values.name)}')
    // access token TTL (used in generateToken controller)
    .setTokenTtl(3600)
    // activate auto parsing of access token (jwtAccessTokenPayload + createJwtAccessToken)
    .useAccessTokenJwks(true)
    // Client authentication methods
    .addClientAuthenticationMethod(new ClientSecretBasic())
    .addClientAuthenticationMethod(new ClientSecretPost())
    .addClientAuthenticationMethod(new NoneAuthMethod())
    .setTokenType(new BearerToken())
    // Define scopes
    .setScopes({
        profile: 'Access to basic profile information such as name and picture.',
        email: "Access to the user's email address and its verification status.",
        read: 'Grants read-only access to protected resources',
        write: 'Grants write access to protected resources',
    })

    // Authorization
    .authorizationRoute<object, { Payload: { username?: string; password?: string } }>((route) =>
        route
            .setPath('/oauth2/v1.0/authorize')
            .setUsernameField('username')
            .setPasswordField('password')
            .generateCode(async ({ clientId, codeChallenge, scope }, req, _h) => {
                // client exists?
                const client = VALID_CLIENTS.find((c) => c.client_id === clientId);
                if (!client) return null;

                // filter client's allowed scoped
                const requestedScopes = (scope ?? '').split(/\\s+/).filter(Boolean);
                const grantedScopes = requestedScopes.length
                    ? requestedScopes.filter((s) => client.allowed_scopes.includes(s))
                    : client.allowed_scopes;
                if (grantedScopes.length === 0) return null;

                // user exists?
                const user = REGISTERED_USERS.find(
                    (u) => u.username === req.payload.username && u.password === req.payload.password
                );
                if (!user) return null;

                // generate code
                const code = \`auth-${Date.now()}\`;
                authCodesStore.set(code, { clientId, scopes: grantedScopes, userId: user.id, codeChallenge });
                return { type: 'code', value: code };
            })
            .finalizeAuthorization(async (ctx, _params, _req, h) => {
                // redirect to callback url (could do something else depending on the code result)
                const matcher = createMatchAuthCodeResult({
                    code: async () => h.redirect(ctx.fullRedirectUri),
                    continue: async () => h.redirect(ctx.fullRedirectUri),
                    deny: async () => h.redirect(ctx.fullRedirectUri),
                });
                return matcher(ctx.authorizationResult);
            })
    )

    // Token exchange
    .tokenRoute((route) =>
        route.generateToken(
            async ({
                clientId,
                ttl,
                tokenType,
                code,
                clientSecret,
                codeVerifier,
                createJwtAccessToken,
                createIdToken,
                verifyCodeVerifier,
            }) => {
                const entry = authCodesStore.get(code);
                if (!entry || entry.clientId !== clientId) return null;

                const client = VALID_CLIENTS.find((c) => c.client_id === clientId);
                if (!client) {
                    return {
                        error: OAuth2ErrorCode.INVALID_CLIENT,
                        error_description: 'Client authentication failed.',
                    };
                }

                if (entry.codeChallenge && codeVerifier) {
                    if (!verifyCodeVerifier(codeVerifier, entry.codeChallenge)) {
                        return {
                            error: OAuth2ErrorCode.INVALID_GRANT,
                            error_description: 'Invalid authorization grant.',
                        };
                    }
                } else if (clientSecret) {
                    if (client.client_secret !== clientSecret) {
                        return {
                            error: OAuth2ErrorCode.INVALID_CLIENT,
                            error_description: 'Client authentication failed.',
                        };
                    }
                } else {
                    return {
                        error: OAuth2ErrorCode.INVALID_REQUEST,
                        error_description: 'Missing or invalid request parameter.',
                    };
                }

                const user = REGISTERED_USERS.find((u) => u.id === entry.userId);
                if (!user) {
                    return {
                        error: OAuth2ErrorCode.INVALID_GRANT,
                        error_description: 'Invalid authorization grant.',
                    };
                }

                // Generate a signed JWT access token
                const { token: accessToken } = await createJwtAccessToken!({
                    sub: entry.userId,
                    client_id: clientId,
                    scope: entry.scopes,
                });

                // Generate a signed JWT id token
                const idToken = entry.scopes.includes('openid')
                    ? (await createIdToken!({ sub: entry.userId, name: user.username, aud: clientId })).token
                    : undefined;

                // Return token response
                return new OAuth2TokenResponse({ access_token: accessToken })
                    .setExpiresIn(ttl)
                    .setTokenType(tokenType)
                    .setScope(entry.scopes)
                    .setIdToken(idToken);
            }
        )
    )

    // Access Token Validation
    .validate(async (_req, { jwtAccessTokenPayload }) => {
        if (!jwtAccessTokenPayload?.sub) return { isValid: false };
        return {
            isValid: true,
            credentials: {
                user: {
                    id: jwtAccessTokenPayload.sub,
                    clientId: jwtAccessTokenPayload.client_id,
                },
                scope: Array.isArray(jwtAccessTokenPayload.scope) ? jwtAccessTokenPayload.scope : [],
            },
        };
    })
        
    // JWKS
    .jwksRoute((route) => route.setPath('/discovery/v1.0/keys')) // activates jwks uri
    .setPublicKeyExpiry(86400) // 24h
    .setJwksKeyStore(createInMemoryKeyStore()) // store for JWKS
    .setJwksRotatorOptions({
        intervalMs: 7.884e9, // 91 days
        timestampStore: createInMemoryKeyStore(),
    });
`
    }

    #getOidcClientCredentialsContent(): string {
        return `// generated by @kaapi/oauth2-auth-design

import {
    OIDCClientCredentialsBuilder,
    OAuth2TokenResponse,
    OAuth2ErrorCode,
    ClientSecretBasic,
    ClientSecretPost,
    BearerToken,
    createInMemoryKeyStore,
} from '@kaapi/oauth2-auth-design';

const VALID_CLIENTS = [
    {
        client_id: 'internal-service',
        client_secret: 'Int3rnalK3y!',
        allowed_scopes: ['read', 'write', 'admin'],
    },
];

export const oidcClientCredentialsBuilder = OIDCClientCredentialsBuilder.create()
    // the name of the strategy
    .strategyName('${kebabCase(this.#values.name)}')
    // access token ttl (used in generateToken controller)
    .setTokenTtl(600)
    // activate auto parsing of access token (jwtAccessTokenPayload + createJwtAccessToken)
    .useAccessTokenJwks(true)
    // Client authentication methods
    .addClientAuthenticationMethod(new ClientSecretBasic())
    .addClientAuthenticationMethod(new ClientSecretPost())
    .setTokenType(new BearerToken())
    // Define available scopes
    .setScopes({
        read: 'Grants read-only access to protected resources',
        write: 'Grants write access to protected resources',
        admin: 'Administrative access',
    })

    // Token exchange
    .tokenRoute((route) =>
        route.generateToken(async ({ clientId, clientSecret, ttl, tokenType, scope, createJwtAccessToken }) => {
            // Validate client credentials
            const client = VALID_CLIENTS.find((c) => c.client_id === clientId && c.client_secret === clientSecret);

            if (!client) {
                return {
                    error: OAuth2ErrorCode.INVALID_CLIENT,
                    error_description: 'Invalid client_id or client_secret',
                };
            }

            // Determine requested scopes
            const requestedScopes = (scope ?? '').split(/\\s+/).filter(Boolean);

            // Compute granted scopes
            let grantedScopes = client.allowed_scopes;
            if (requestedScopes.length > 0) {
                grantedScopes = requestedScopes.filter((s) => client.allowed_scopes.includes(s));
            }

            if (grantedScopes.length === 0) {
                return {
                    error: OAuth2ErrorCode.INVALID_SCOPE,
                    error_description: 'No valid scopes granted for this client',
                };
            }

            // Generate a signed JWT access token
            const { token: accessToken } = await createJwtAccessToken!({
                sub: clientId,
                app: true,
                scope: grantedScopes,
            });

            // Return token response
            return new OAuth2TokenResponse({ access_token: accessToken })
                .setExpiresIn(ttl)
                .setTokenType(tokenType)
                .setScope(grantedScopes.join(' '));
        })
    )

    // Access Token Validation
    .validate(async (_req, { jwtAccessTokenPayload }) => {
        if (!jwtAccessTokenPayload?.sub || !jwtAccessTokenPayload.app) return { isValid: false };
        return {
            isValid: true,
            credentials: {
                app: {
                    id: jwtAccessTokenPayload.sub,
                },
                scope: Array.isArray(jwtAccessTokenPayload.scope) ? jwtAccessTokenPayload.scope : [],
            },
        };
    })

    // JWKS
    .jwksRoute((route) => route.setPath('/discovery/v1.0/keys')) // activates jwks uri
    .setPublicKeyExpiry(86400) // 24h
    .setJwksKeyStore(createInMemoryKeyStore()) // store for JWKS
    .setJwksRotatorOptions({
        intervalMs: 7.884e9, // 91 days
        timestampStore: createInMemoryKeyStore(),
    });
`
    }

    #getOidcDeviceFlowContent(): string {
        return `// generated by @kaapi/oauth2-auth-design

import {
    BearerToken,
    OIDCAuthorizationCodeBuilder,
    createInMemoryKeyStore,
    createMatchAuthCodeResult,
    OAuth2TokenResponse,
    ClientSecretBasic,
    ClientSecretPost,
    NoneAuthMethod,
    OAuth2ErrorCode,
} from '@kaapi/oauth2-auth-design';

const VALID_CLIENTS = [
    {
        client_id: 'service-api-client',
        client_secret: 's3cr3tK3y123!',
        allowed_scopes: ['openid', 'profile', 'email', 'read', 'write'],
    },
];

const REGISTERED_USERS = [{ id: 'user-1234', username: 'user', password: 'password', email: 'user@email.com' }];

const authCodesStore: Map<
    string,
    { clientId: string; scopes: string[]; userId: string; codeChallenge?: string | undefined }
> = new Map();

export const oidcAuthCodeBuilder = OIDCAuthorizationCodeBuilder.create()
    // the name of the strategy
    .strategyName('${kebabCase(this.#values.name)}')
    // access token TTL (used in generateToken controller)
    .setTokenTtl(3600)
    // activate auto parsing of access token (jwtAccessTokenPayload + createJwtAccessToken)
    .useAccessTokenJwks(true)
    // Client authentication methods
    .addClientAuthenticationMethod(new ClientSecretBasic())
    .addClientAuthenticationMethod(new ClientSecretPost())
    .addClientAuthenticationMethod(new NoneAuthMethod())
    .setTokenType(new BearerToken())
    // Define scopes
    .setScopes({
        profile: 'Access to basic profile information such as name and picture.',
        email: "Access to the user's email address and its verification status.",
        read: 'Grants read-only access to protected resources',
        write: 'Grants write access to protected resources',
    })

    // Authorization
    .authorizationRoute<object, { Payload: { username?: string; password?: string } }>((route) =>
        route
            .setPath('/oauth2/v1.0/authorize')
            .setUsernameField('username')
            .setPasswordField('password')
            .generateCode(async ({ clientId, codeChallenge, scope }, req, _h) => {
                // client exists?
                const client = VALID_CLIENTS.find((c) => c.client_id === clientId);
                if (!client) return null;

                // filter client's allowed scoped
                const requestedScopes = (scope ?? '').split(/\\s+/).filter(Boolean);
                const grantedScopes = requestedScopes.length
                    ? requestedScopes.filter((s) => client.allowed_scopes.includes(s))
                    : client.allowed_scopes;
                if (grantedScopes.length === 0) return null;

                // user exists?
                const user = REGISTERED_USERS.find(
                    (u) => u.username === req.payload.username && u.password === req.payload.password
                );
                if (!user) return null;

                // generate code
                const code = \`auth-${Date.now()}\`;
                authCodesStore.set(code, { clientId, scopes: grantedScopes, userId: user.id, codeChallenge });
                return { type: 'code', value: code };
            })
            .finalizeAuthorization(async (ctx, _params, _req, h) => {
                // redirect to callback url (could do something else depending on the code result)
                const matcher = createMatchAuthCodeResult({
                    code: async () => h.redirect(ctx.fullRedirectUri),
                    continue: async () => h.redirect(ctx.fullRedirectUri),
                    deny: async () => h.redirect(ctx.fullRedirectUri),
                });
                return matcher(ctx.authorizationResult);
            })
    )

    // Token exchange
    .tokenRoute((route) =>
        route.generateToken(
            async ({
                clientId,
                ttl,
                tokenType,
                code,
                clientSecret,
                codeVerifier,
                createJwtAccessToken,
                createIdToken,
                verifyCodeVerifier,
            }) => {
                const entry = authCodesStore.get(code);
                if (!entry || entry.clientId !== clientId) return null;

                const client = VALID_CLIENTS.find((c) => c.client_id === clientId);
                if (!client) {
                    return {
                        error: OAuth2ErrorCode.INVALID_CLIENT,
                        error_description: 'Client authentication failed.',
                    };
                }

                if (entry.codeChallenge && codeVerifier) {
                    if (!verifyCodeVerifier(codeVerifier, entry.codeChallenge)) {
                        return {
                            error: OAuth2ErrorCode.INVALID_GRANT,
                            error_description: 'Invalid authorization grant.',
                        };
                    }
                } else if (clientSecret) {
                    if (client.client_secret !== clientSecret) {
                        return {
                            error: OAuth2ErrorCode.INVALID_CLIENT,
                            error_description: 'Client authentication failed.',
                        };
                    }
                } else {
                    return {
                        error: OAuth2ErrorCode.INVALID_REQUEST,
                        error_description: 'Missing or invalid request parameter.',
                    };
                }

                const user = REGISTERED_USERS.find((u) => u.id === entry.userId);
                if (!user) {
                    return {
                        error: OAuth2ErrorCode.INVALID_GRANT,
                        error_description: 'Invalid authorization grant.',
                    };
                }

                // Generate a signed JWT access token
                const { token: accessToken } = await createJwtAccessToken!({
                    sub: entry.userId,
                    client_id: clientId,
                    scope: entry.scopes,
                });

                // Generate a signed JWT id token
                const idToken = entry.scopes.includes('openid')
                    ? (await createIdToken!({ sub: entry.userId, name: user.username, aud: clientId })).token
                    : undefined;

                // Return token response
                return new OAuth2TokenResponse({ access_token: accessToken })
                    .setExpiresIn(ttl)
                    .setTokenType(tokenType)
                    .setScope(entry.scopes)
                    .setIdToken(idToken);
            }
        )
    )

    // Access Token Validation
    .validate(async (_req, { jwtAccessTokenPayload }) => {
        if (!jwtAccessTokenPayload?.sub) return { isValid: false };
        return {
            isValid: true,
            credentials: {
                user: {
                    id: jwtAccessTokenPayload.sub,
                    clientId: jwtAccessTokenPayload.client_id,
                },
                scope: Array.isArray(jwtAccessTokenPayload.scope) ? jwtAccessTokenPayload.scope : [],
            },
        };
    })
        
    // JWKS
    .jwksRoute((route) => route.setPath('/discovery/v1.0/keys')) // activates jwks uri
    .setPublicKeyExpiry(86400) // 24h
    .setJwksKeyStore(createInMemoryKeyStore()) // store for JWKS
    .setJwksRotatorOptions({
        intervalMs: 7.884e9, // 91 days
        timestampStore: createInMemoryKeyStore(),
    });
`
    }
}